{"ast":null,"code":"import _objectSpread from \"/home/taifdev/Desktop/reactProj/crwn-clothing/redux/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\n// this won't be a .jsx file  since it doesn't contain any jsx. So, it will be a .js file\n// A reducer is just a function that gets 2 properties. It gets state object, which represents the last state or an initial state Which is just an object which represents what we want to store.\n// And then it receives an action. Action is just an object that has a type which is a string value\n// {\n//     type: string,\n//     // specific it means we are going to write a bunch of actions.We will name them whatever it is we want.\n//     // Make sure that our reducers are aware of the specific type of action that's coming\n//     //and it will be based off this type property\n//     payload: \n//     // payload can be anything. Anything because maybe we want to do something with it in order to update our state\n//     // we might pass an object that we literally set as the value in our state or we might use this value\n//     // to make some transformations on our state\n// }\n// actions are just an object that have these 2 properties\nconst INITIAL_STATE = {\n  currentUser: null // we will use this as default parameter value\n  // Default parameter value: state = INITAL_STATE \n\n};\n\nconst userReducer = (state = INITIAL_STATE, action) => {\n  // The State -> is going to something that the redux store is going to pass to this reducer whenever an action fires\n  // and the state will be whatever the state is currently when that action gets fire. First time, State = nothing\n  //so we have to set an initial state\n  // swith statement:\n  switch (action.type) {\n    // action.type will be a string\n    // we could use if-else statments too\n    case 'SET_CURRENT_USER':\n      // if the case is what we want, then we will render something\n      // whenever SET_CURRENT_USER is the action type that gets fired, return a new object which represents the new state that our user\n      return _objectSpread({}, state, {\n        // we're spreading everything on the state.Always\n        currentUser: action.payload // we're just setting the currentUser value with the payload\n\n      });\n\n    default:\n      //  otherwise just return the state\n      //  The caveat to remember: \n      //  every single reducer gets every single action that ever gets fire. Even if those actions are not related this reducer    \n      return state;\n    // currentState what the  \n  }\n};\n\nexport default userReducer;","map":{"version":3,"sources":["/home/taifdev/Desktop/reactProj/crwn-clothing/redux/src/redux/user/user.reducer.js"],"names":["INITIAL_STATE","currentUser","userReducer","state","action","type","payload"],"mappings":";AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA,MAAMA,aAAa,GAAG;AAClBC,EAAAA,WAAW,EAAE,IADK,CAElB;AAGJ;;AALsB,CAAtB;;AAMA,MAAMC,WAAW,GAAG,CAACC,KAAK,GAAGH,aAAT,EAAyBI,MAAzB,KAAoC;AACpD;AACA;AAEA;AAIA;AACA,UAAOA,MAAM,CAACC,IAAd;AACI;AACA;AAGA,SAAK,kBAAL;AACI;AACA;AACA,+BAEOF,KAFP;AAEc;AACVF,QAAAA,WAAW,EAAEG,MAAM,CAACE,OAHxB,CAGgC;;AAHhC;;AAMJ;AACI;AACA;AACA;AAEA,aAAOH,KAAP;AAAc;AAnBtB;AAsBH,CA/BD;;AAiCA,eAAeD,WAAf","sourcesContent":["// this won't be a .jsx file  since it doesn't contain any jsx. So, it will be a .js file\n\n// A reducer is just a function that gets 2 properties. It gets state object, which represents the last state or an initial state Which is just an object which represents what we want to store.\n// And then it receives an action. Action is just an object that has a type which is a string value\n\n// {\n//     type: string,\n//     // specific it means we are going to write a bunch of actions.We will name them whatever it is we want.\n//     // Make sure that our reducers are aware of the specific type of action that's coming\n//     //and it will be based off this type property\n\n//     payload: \n//     // payload can be anything. Anything because maybe we want to do something with it in order to update our state\n//     // we might pass an object that we literally set as the value in our state or we might use this value\n//     // to make some transformations on our state\n// }\n\n// actions are just an object that have these 2 properties\n\n\nconst INITIAL_STATE = {\n    currentUser: null\n    // we will use this as default parameter value\n}\n\n// Default parameter value: state = INITAL_STATE \nconst userReducer = (state = INITIAL_STATE , action) => {\n    // The State -> is going to something that the redux store is going to pass to this reducer whenever an action fires\n    // and the state will be whatever the state is currently when that action gets fire. First time, State = nothing\n    \n    //so we have to set an initial state\n\n\n\n    // swith statement:\n    switch(action.type) {\n        // action.type will be a string\n        // we could use if-else statments too\n\n\n        case 'SET_CURRENT_USER':\n            // if the case is what we want, then we will render something\n            // whenever SET_CURRENT_USER is the action type that gets fired, return a new object which represents the new state that our user\n            return {\n\n                ...state, // we're spreading everything on the state.Always\n                currentUser: action.payload // we're just setting the currentUser value with the payload\n                 \n            }\n        default:\n            //  otherwise just return the state\n            //  The caveat to remember: \n            //  every single reducer gets every single action that ever gets fire. Even if those actions are not related this reducer    \n            \n            return state; // currentState what the  \n        }   \n\n}\n\nexport default userReducer;"]},"metadata":{},"sourceType":"module"}